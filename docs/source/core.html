<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var
<span id='OO'>	/**
</span>	 * Namespace for all classes, static methods and static properties.
	 * @class OO
	 * @singleton
	 */
	oo = {},
	hasOwn = oo.hasOwnProperty,
	toString = oo.toString;

/* Class Methods */


<span id='OO-method-isPlainObject'>/**
</span> * Assert whether a value is a plain object or not.
 *
 * @method
 * @param {Mixed} obj
 * @return {boolean}
 */
oo.isPlainObject = function ( obj ) {
	// Any object or value whose internal [[Class]] property is not &quot;[object Object]&quot;
	if ( toString.call( obj ) !== &#39;[object Object]&#39; ) {
		return false;
	}

	// The try/catch suppresses exceptions thrown when attempting to access
	// the &quot;constructor&quot; property of certain host objects suich as window.location
	// in Firefox &lt; 20 (https://bugzilla.mozilla.org/814622)
	try {
		if ( obj.constructor &amp;&amp;
				!hasOwn.call( obj.constructor.prototype, &#39;isPrototypeOf&#39; ) ) {
			return false;
		}
	} catch ( e ) {
		return false;
	}

	return true;
};

<span id='OO-method-inheritClass'>/**
</span> * Utility for common usage of Object#create for inheriting from one
 * prototype to another.
 *
 * Beware: This redefines the prototype, call before setting your prototypes.
 * Beware: This redefines the prototype, can only be called once on a function.
 *  If called multiple times on the same function, the previous prototype is lost.
 *  This is how prototypal inheritance works, it can only be one straight chain
 *  (just like classical inheritance in PHP for example). If you need to work with
 *  multiple constructors consider storing an instance of the other constructor in a
 *  property instead, or perhaps use a mixin (see oo.mixinClass).
 *
 *     function Foo() {}
 *     Foo.prototype.jump = function () {};
 *
 *     function FooBar() {}
 *     oo.inheritClass( FooBar, Foo );
 *     FooBar.prop.feet = 2;
 *     FooBar.prototype.walk = function () {};
 *
 *     function FooBarQuux() {}
 *     OO.inheritClass( FooBarQuux, FooBar );
 *     FooBarQuux.prototype.jump = function () {};
 *
 *     FooBarQuux.prop.feet === 2;
 *     var fb = new FooBar();
 *     fb.jump();
 *     fb.walk();
 *     fb instanceof Foo &amp;&amp; fb instanceof FooBar &amp;&amp; fb instanceof FooBarQuux;
 *
 * @method
 * @param {Function} targetFn
 * @param {Function} originFn
 * @throws {Error} If target already inherits from origin
 */
oo.inheritClass = function ( targetFn, originFn ) {
	if ( targetFn.prototype instanceof originFn ) {
		throw new Error( &#39;Target already inherits from origin&#39; );
	}

	var targetConstructor = targetFn.prototype.constructor;

	targetFn.prototype = Object.create( originFn.prototype );

	// Restore constructor property of targetFn
	targetFn.prototype.constructor = targetConstructor;

	// Extend static properties - always initialize both sides
	originFn.static = originFn.static || {};
	targetFn.static = Object.create( originFn.static );

	// Copy mixin tracking
	targetFn.mixins = originFn.mixins ? originFn.mixins.slice( 0 ) : [];
};

<span id='OO-method-mixinClass'>/**
</span> * Utility to copy over *own* prototype properties of a mixin.
 * The &#39;constructor&#39; (whether implicit or explicit) is not copied over.
 *
 * This does not create inheritance to the origin. If inheritance is needed
 * use oo.inheritClass instead.
 *
 * Beware: This can redefine a prototype property, call before setting your prototypes.
 * Beware: Don&#39;t call before oo.inheritClass.
 *
 *     function Foo() {}
 *     function Context() {}
 *
 *     // Avoid repeating this code
 *     function ContextLazyLoad() {}
 *     ContextLazyLoad.prototype.getContext = function () {
 *         if ( !this.context ) {
 *             this.context = new Context();
 *         }
 *         return this.context;
 *     };
 *
 *     function FooBar() {}
 *     OO.inheritClass( FooBar, Foo );
 *     OO.mixinClass( FooBar, ContextLazyLoad );
 *
 * @method
 * @param {Function} targetFn
 * @param {Function} originFn
 */
oo.mixinClass = function ( targetFn, originFn ) {
	var key;

	// Copy prototype properties
	for ( key in originFn.prototype ) {
		if ( key !== &#39;constructor&#39; &amp;&amp; hasOwn.call( originFn.prototype, key ) ) {
			targetFn.prototype[key] = originFn.prototype[key];
		}
	}

	// Copy static properties - always initialize both sides
	targetFn.static = targetFn.static || {};
	if ( originFn.static ) {
		for ( key in originFn.static ) {
			if ( hasOwn.call( originFn.static, key ) ) {
				targetFn.static[key] = originFn.static[key];
			}
		}
	} else {
		originFn.static = {};
	}
};

/* Object Methods */

<span id='OO-method-cloneObject'>/**
</span> * Create a new object that is an instance of the same
 * constructor as the input, inherits from the same object
 * and contains the same own properties.
 *
 * This makes a shallow non-recursive copy of own properties.
 * To create a recursive copy of plain objects, use #copy.
 *
 *     var foo = new Person( mom, dad );
 *     foo.setAge( 21 );
 *     var foo2 = OO.cloneObject( foo );
 *     foo.setAge( 22 );
 *
 *     // Then
 *     foo2 !== foo; // true
 *     foo2 instanceof Person; // true
 *     foo2.getAge(); // 21
 *     foo.getAge(); // 22
 *
 * @method
 * @param {Object} origin
 * @return {Object} Clone of origin
 */
oo.cloneObject = function ( origin ) {
	var key, r;

	r = Object.create( origin.constructor.prototype );

	for ( key in origin ) {
		if ( hasOwn.call( origin, key ) ) {
			r[key] = origin[key];
		}
	}

	return r;
};

<span id='OO-method-getObjectValues'>/**
</span> * Gets an array of all property values in an object.
 *
 * @method
 * @param {Object} Object to get values from
 * @returns {Array} List of object values
 */
oo.getObjectValues = function ( obj ) {
	var key, values;

	if ( obj !== Object( obj ) ) {
		throw new TypeError( &#39;Called on non-object&#39; );
	}

	values = [];
	for ( key in obj ) {
		if ( hasOwn.call( obj, key ) ) {
			values[values.length] = obj[key];
		}
	}

	return values;
};

<span id='OO-method-compare'>/**
</span> * Recursively compares properties between two objects.
 *
 * A false result may be caused by property inequality or by properties in one object missing from
 * the other. An asymmetrical test may also be performed, which checks only that properties in the
 * first object are present in the second object, but not the inverse.
 *
 * @method
 * @param {Object} a First object to compare
 * @param {Object} b Second object to compare
 * @param {boolean} [asymmetrical] Whether to check only that b contains values from a
 * @returns {boolean} If the objects contain the same values as each other
 */
oo.compare = function ( a, b, asymmetrical ) {
	var aValue, bValue, aType, bType, k;
	for ( k in a ) {
		aValue = a[k];
		bValue = b[k];
		aType = typeof aValue;
		bType = typeof bValue;
		if ( aType !== bType ||
			( ( aType === &#39;string&#39; || aType === &#39;number&#39; ) &amp;&amp; aValue !== bValue ) ||
			( aValue === Object( aValue ) &amp;&amp; !oo.compare( aValue, bValue, asymmetrical ) ) ) {
			return false;
		}
	}
	// If the check is not asymmetrical, recursing with the arguments swapped will verify our result
	return asymmetrical ? true : oo.compare( b, a, true );
};

<span id='OO-method-copy'>/**
</span> * Create a plain deep copy of any kind of object.
 *
 * Copies are deep, and will either be an object or an array depending on `source`.
 *
 * @method
 * @param {Object} source Object to copy
 * @param {Function} [callback] Applied to leaf values before they added to the clone
 * @returns {Object} Copy of source object
 */
oo.copy = function ( source, callback ) {
	var key, sourceValue, sourceType, destination;

	if ( typeof source.clone === &#39;function&#39; ) {
		return source.clone();
	}

	destination = Array.isArray( source ) ? new Array( source.length ) : {};

	for ( key in source ) {
		sourceValue = source[key];
		sourceType = typeof sourceValue;
		if ( Array.isArray( sourceValue ) ) {
			// Array
			destination[key] = oo.copy( sourceValue, callback );
		} else if ( sourceValue &amp;&amp; typeof sourceValue.clone === &#39;function&#39; ) {
			// Duck type object with custom clone method
			destination[key] = callback ?
				callback( sourceValue.clone() ) : sourceValue.clone();
		} else if ( sourceValue &amp;&amp; typeof sourceValue.cloneNode === &#39;function&#39; ) {
			// DOM Node
			destination[key] = callback ?
				callback( sourceValue.cloneNode( true ) ) : sourceValue.cloneNode( true );
		} else if ( oo.isPlainObject( sourceValue ) ) {
			// Plain objects
			destination[key] = oo.copy( sourceValue, callback );
		} else {
			// Non-plain objects (incl. functions) and primitive values
			destination[key] = callback ? callback( sourceValue ) : sourceValue;
		}
	}

	return destination;
};
</pre>
</body>
</html>
